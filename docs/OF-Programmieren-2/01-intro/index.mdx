---
page_id: 84f95bc1-847e-4178-9e7f-789082e1a083
---

import Strukto from '@tdev-components/VisualizationTools/Strukto'

# 1. Intro

## Algorithmus

> ¬´Ein Algorithmus beschreibt die Methode, mit der eine Aufgabe gel√∂st wird. Ein Algorithmus besteht aus einer Folge von Schritten, deren korrekte Abarbeitung die gestellte Aufgabe l√∂st. Die Abarbeitung oder den Vorgang selbst bezeichnet man als Proze√ü.¬ª
> 
> Les Goldschlager/Andrew Lister: *Informatik*, 1984


Damit wir von einem Algorithmus sprechen, m√ºssen also **zwei** Bedingungen erf√ºllt sein:
1. Es muss eine **Schritt-f√ºr-Schritt-Anleitung** vorliegen.
2. Diese Schritt-f√ºr-Schritt-Anleitung muss eine **Aufgabe oder ein Problem l√∂sen**.

## Struktur
Ein Algorithmus definiert, in welcher **Reihenfolge** die einzelnen Schritte nacheinander abgearbeitet werden. Die Beschreibung dieser Reihenfolge ist die **Struktur** des Algorithmus. W√§hrend die Einzelschritte je nach Anwendungsgebiet unterschiedlich sind, sind die Strukturen (beim Programmieren spricht man von **Kontrollstrukturen**) von Algorithmen universell.

Folgende Strukturen k√∂nnen unterschieden werden:
Sequenz üë£
: eine Folge von Schritten/Anweisungen, die nacheinander abgearbeitet werden.
:::dd
```py live_py slim
from turtle import *

forward(100)
left(120)
forward(100)
left(120)
forward(100)
left(120)
:::
Wiederholung üîÅ
: Einer oder mehrere Schritte werden eine bestimmte Anzahl mal wiederholt.
:::dd
```py live_py slim
from turtle import *

for i in range(3):
    forward(100)
    left(120)
:::
Bedingte Ausf√ºhrung ‚ëÇ
: Einer oder mehrere Schritte werden nur ausgef√ºhrt, wenn eine bestimmte Bedingung erf√ºllt ist.
:::dd
```py live_py slim
from random import randint

zahl1 = randint(1, 10)
zahl2 = randint(1, 10)
antwort = input(f'{zahl1} * {zahl2} = ? ')
antwort = int(antwort)
l√∂sung = zahl1 * zahl2
if antwort == l√∂sung:
    print(f'üòé Richtig! {zahl1} * {zahl2} = {l√∂sung}')
else:
    print(f'ü•∏ {antwort} ist Falsch! {zahl1} * {zahl2} = {l√∂sung}')
:::
Unterprogramm üè∑
: Eine Sequenz kann mit einem Namen versehen werden. Anstatt immer die ganze Sequenz aufzuschreiben, kann der Name angegeben werden.
:::dd
```py live_py slim
from turtle import *
def dreieck():
    for i in range(3):
        forward(100)
        left(120)
dreieck()
left(90)
dreieck()
:::
Parameter ‚äï ‚äñ
: Das Ergebnis eines Algorithmus kann variiert werden durch Werte, welche bei jeder Ausf√ºhrung neu festgelegt werden.
:::dd
```py live_py slim
from turtle import *
def dreieck(seitenl√§nge, farbe):
    color(farbe)
    for i in range(3):
        forward(seitenl√§nge)
        left(120)
dreieck(100, 'blue')
dreieck(50, 'red')
```
:::

## Schleifen

Mit **Schleifen** k√∂nnen Anweisungen wiederholt ausgef√ºhrt werden, ohne dass diese mehrfach aufgeschrieben werden m√ºssen. Es gibt zwei Arten von Schleifen:
- **Z√§hlschleifen**: Die Anzahl der Wiederholungen ist im Voraus bekannt.
- **Bedingte Schleifen**: Die Anzahl der Wiederholungen ist nicht im Voraus bekannt, sondern h√§ngt von einer Bedingung ab.

Bisher haben wir nur Z√§hlschleifen - die `for`-Schleife - kennengelernt.

### Die `for`-Schleife
```py live_py slim
from turtle import *

for i in range(5):
    forward(100)
    left(72)
```

Das `i` in der Schleife ist der sog. **Schleifenz√§hler**. Er wird bei jeder Wiederholung um 1 erh√∂ht und beginnt standardm√§ssig bei `0`. **Der Schleifenz√§hler kann innerhalb der Schleife verwendet werden.**

```py live_py slim
from turtle import *

for i in range(5):
    forward(10 * i)  # Die L√§nge der Linie h√§ngt vom Schleifenz√§hler ab
    left(90)
```

:::tip[Beachte]
Es gibt **nur 4** gezeichnete Linien, da der Schleifenz√§hler bei `0` beginnt und bis `4` geht (was auf **Z. 4** Seitenl√§ngen von `0`, `10`, `20`, `30`, `40` erzeugt).
:::

:::def[`for i in range(start, stopp):`]
Die `for`-Schleife kann auch mit zwei Parametern verwendet werden: `start` und `stopp`. Der Schleifenz√§hler beginnt dann bei `start` und l√§uft bis `stopp - 1`.

```py live_py slim
from turtle import *

for i in range(1, 6):  # Schleifenz√§hler l√§uft von 1 bis 5
    forward(10 * i)
    left(90)
```
:::

:::insight[Merke]
Bei der `for`-Schleife muss bereits im **Voraus** bekannt sein, wie oft die Schleife durchlaufen werden soll.
:::

### Die `while`-Schleife
Die `while`-Schleife ist eine **bedingte Schleife**, ein Code-Block wird so lange wiederholt, wie eine bestimmte Bedingung erf√ºllt ist. Z√§hl-Schleifen k√∂nnen immer auch mit einer `while`-Schleife realisiert werden - es braucht dazu aber eine zus√§tzliche Variable, die den Z√§hlerstand speichert.

:::cards{flexBasis=300px}
    **`for`-Schleife**

    ```py live_py slim minLines=7
    from turtle import *


    for i in range(4):
        forward(100)
        left(90)
    ```
::br
    **`while`-Schleife**

    ```py live_py slim
    from turtle import *

    i = 0
    while i < 4:
        forward(100)
        left(90)
        i = i + 1
    ```
:::
:::::tip[Beachte]
<div className="compactDeflist">
    Z. 3
    : Der Schleifenz√§hler `i` wird initialisiert (auf `0` gesetzt).
    Z. 4
    : Die Bedingung der Schleife. Solange `i` kleiner als `4` ist, wird die Schleife ausgef√ºhrt.
    Z. 8
    : Der Schleifenz√§hler wird um `1` erh√∂ht.
    ::::dd
        :::warning[Achtung: :mdi[all-inclusive]-Schleifen!]
        Wenn die Bedingung der `while`-Schleife **niemals** falsch wird, l√§uft die Schleife unendlich weiter. Dann muss der Tab geschlossen und erneut ge√∂ffnet werden!
        :::
    ::::
</div>
:::::


::::aufgabe[`for` zu `while`]
<Answer type="state" id="a3946a2c-10d3-400f-86e8-4c6546e72fe6" />

Schreiben Sie das untenstehende Programm so um, dass nur noch `while` Schleifen verwendet werden.

:::flex{flexBasis="200px"}
```py live_py slim
from turtle import *

left(60)

for i in range(5):
    forward(100)
    left(72)
    backward(20) 
```

::br

```py live_py title=to-while.py id=2f288418-a751-4955-91e6-44ef58a2844b
from turtle import *
```
:::

<Solution id="1a34bc16-5fb1-4e2e-bf0e-9a08455e7579">
  ```py live_py slim
  from turtle import *

  left(60)
  i = 0
  while i < 5:
      forward(100)
      left(72)
      backward(20)
      i = i + 1
  ```
</Solution>
::::


Die eigentliche St√§rke der `while`-Schleife liegt aber darin, dass die Anzahl Wiederholungen **im Voraus nicht bekannt** sein muss. Die Schleife l√§uft so lange, bis eine bestimmte Bedingung erf√ºllt ist.

Obiges Kopfrechnen-Beispiel k√∂nnte mit einer `while`-Schleife zu einem Kopfrechnen-Trainer erweitert werden, der so lange neue Aufgaben stellt, bis `x` eingegeben wird:

```py live_py slim
from browser import alert
antwort = ''
while antwort != 'x':
    zahl1 = randint(1, 10)
    zahl2 = randint(1, 10)
    antwort = input(f'{zahl1} * {zahl2} = ? (x zum Beenden) ')
    if antwort != 'x':
        antwort = int(antwort)
        l√∂sung = zahl1 * zahl2
        if antwort == l√∂sung:
            alert(f'üòé Richtig! {zahl1} * {zahl2} = {l√∂sung}')
        else:
            alert(f'ü•∏ {antwort} ist Falsch! {zahl1} * {zahl2} = {l√∂sung}')

```

## Anwendung

Die `while`-Schleife kommt oft bei Benutzerinteraktionen, Simulationen oder bei sich dynamisch √§ndernden Daten vor. Sonstige Wiederholungen lassen sich normalerweise einfacher mit einer `for`-Schleife umsetzen.

:::insight
<div className="smallDeflist">
  `while`-Schleife
  : Die `while`-Schleife wird immer dann verwendet, wenn die Anzahl Wiederholungen **im Voraus unbekannt** ist.
  `for`-Schleife
  : Ist die Anzahl Wiederholungen **im Voraus bekannt**, wird meistens die `for`-Schleife verwendet.
</div>
:::