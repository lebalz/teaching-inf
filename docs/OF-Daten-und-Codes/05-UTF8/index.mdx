---
page_id: b8b4c517-996a-48a6-a6ca-0d87e3a014a1
---

import BinDecoder from '@tdev-components/VisualizationTools/BinDecoder'

# 5. UTF-8

Werden Unicode-Zeichen ins bin√§re √ºbersetzt wird klar, dass diese Zahlen nicht mehr nur mit einem Byte dargestellt werden k√∂nnen. Beispielsweise ist dem Affen-Emoji üêí die Zahl $128018_{10}$ zugewiesen, was der Bin√§rzahl $00000001\:11110100\:00010010_{2}$ entspricht, also `3` Bytes Speicherplatz ben√∂tigt.


:::info
1 Byte
: entspricht $8$ Bit
1 Megabit
: entspricht $1'000'000$ Bit
1 Megabyte
: entspricht $1'000'000$ Bytes oder $8'000'000$ Bit
:::

UTF-8
: ist ein Code, der Unicode-Zeichen in Bitmuster √ºbersetzt. Ein Unicode-Zeichen wird mit ein bis vier Bytes (daher 8-32 bit) dargestellt. Die folgende Tabelle zeigt, wie die Codierung funktioniert:

| Unicode-Bereich |                             Bitmuster | Anzahl Bit | Byte 1: Anzahl Kontroll-Bits |
| --------------: | ------------------------------------: | ---------: | ---------------------------: |
|       0 bis 127 |                            `0xxxxxxx` |          7 |                            1 |
|    128 bis 2047 |                   `110xxxxx 10xxxxxx` |         11 |                            3 |
|  2048 bis 65535 |          `1110xxxx 10xxxxxx 10xxxxxx` |         16 |                            4 |
|        ab 65536 | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` |         21 |                            5 |

Unicode-Zeichen mit einer Nummer zwischen 0 und 127 werden mit einem Byte dargestellt, welches mit `0` beginnt. Somit ist UTF-8 in diesem Bereich identisch mit ASCII (und Latin 1).

F√ºr die anderen Zeichen wird mehr als ein Byte verwendet. Dabei beginnt jedes Byte mit einer oder mehreren `1`, gefolgt von einer `0`. Die Anzahl `1` im ersten Byte definieren, wie viele Bytes f√ºr das Zeichen verwendet werden. Die folgenden Bytes werden mit `10` markiert. Die `x` werden mit der Bin√§rdarstellung der Unicode-Nummer aufgef√ºllt.

|                       Zeichen | Nummer |                             Bitmuster |
| ----------------------------: | -----: | ------------------------------------: |
|                             A |     65 |                            `01000001` |
|                             √§ |    228 |                   `11000011 10100100` |
| Schwarze Sonne mit Strahlen ‚òÄ |   9728 |          `11100010 10011000 10000000` |
|                        Affe üêí | 128018 | `11110000 10011111 10010000 10010010` |

Der Vorteil dieser Codierung ist, dass anhand der ersten Bits eines Bytes erkannt wird, ob es sich um den Anfang oder die Fortsetzung eines Zeichens handelt.

| Beginn |                                     Bedeutung |
| -----: | --------------------------------------------: |
|     0‚Ä¶ |                                 ASCII-Zeichen |
|    10‚Ä¶ | Fortsetzung eines Zeichens mit mehreren Bytes |
|   110‚Ä¶ |          Beginn eines Zeichens mit zwei Bytes |
|  1110‚Ä¶ |          Beginn eines Zeichens mit drei Bytes |
| 11110‚Ä¶ |          Beginn eines Zeichens mit vier Bytes |

Dies wird noch deutlicher, wenn man dies als Bin√§rbaum darstellt:

![UTF-8 Pr√§fix](images/utf-8-prefix.svg)

## Ausprobieren

<BinDecoder />

:::aufgabe
<Answer type="state" id="4a80bf12-cb19-47fa-8533-213c679f6e3d" />

Codieren Sie Ihre zwei lieblings Emojis als UTF-8 Bin√§r-Kette mit folgendem Vorgehen:
1. Verwenden Sie f√ºr das Herausfinden der bin√§ren Codierung die Hilfe von Python. (Im Beispiel f√ºr den Stern: `10101101010000`)
2. Codieren Sie die Bin√§rzahl zu UTF-8 und halten Sie das Resultat unten fest.
3. Probieren Sie mit dem obigem Decoder aus, ob das Emoji korrekt versendet wird.
4. Markieren Sie die Aufgabe als erledigt.

```py live_py id=437eee60-2003-4d6b-b0ae-2f967a7b8680
emoji = '‚≠ê'
dec_emoji = ord(emoji) # Unicode Nummer als Dezimalzahl
bin_emoji = bin(dec_emoji)[2:] # Unicode Nummer als Bin√§rzahl
print(f'Zahl: {dec_emoji}, Bin√§r: {bin_emoji}')
```

<Answer type="text" id="91f5e478-a09b-495f-93a4-d7169ae34fdc" />
:::

## Mehrstufige Codierung [^1]


Oft werden Informationen mehrstufig codiert. So wird beispielsweise die Information ¬´Ich bin m√ºde.¬ª als Emoji dargestellt. Das Handy ordnet dem Emoji die entsprechende Unicode-Nummer zu. Diese wird mit UTF-8 in eine Bitfolge √ºbersetzt, welche √ºber das Mobilfunknetz √ºbermittelt wird.

Das Handy des Empf√§ngers √ºbersetzt die Bitfolge wieder zur√ºck in eine Unicode-Nummer und das entsprechende Emoji. Die Interpretation des Emojis muss vom Empf√§nger selbst vorgenommen werden.

![Unicode zu UTF-8](./images/unicode.svg)


[^1]: Remix [rothe.io](https://rothe.io/?page=code/3-text/5-code/)
