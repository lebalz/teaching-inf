/**
 * A Markdown or MDX Page
 */

import { action, computed, observable, ObservableMap } from 'mobx';
import { AUTO_GENERATED_PAGE_PREFIX, PageStore } from '@tdev-stores/PageStore';
import _ from 'es-toolkit/compat';
import iDocument from '@tdev-models/iDocument';
import StudentGroup from '@tdev-models/StudentGroup';
import { DocumentType } from '@tdev-api/document';
import { iTaskableDocument } from './iTaskableDocument';
import { mdiCheckCircleOutline, mdiSpeedometer, mdiSpeedometerMedium, mdiSpeedometerSlow } from '@mdi/js';
import { IfmColors } from '@tdev-components/shared/Colors';
interface PageConfig {
    type: DocumentType;
    position: number;
}

export default class Page {
    readonly store: PageStore;
    readonly id: string;
    readonly path: string;
    initialLoadComplete = false;

    @observable.ref accessor _primaryViewedStudentGroupName: string | undefined = undefined;
    @observable.ref accessor _viewedStudentGroup: StudentGroup | undefined = undefined;
    documentRootConfigs: ObservableMap<string, PageConfig>;

    dynamicValues = observable.map<string, string>();

    constructor(id: string, path: string, store: PageStore) {
        this.id = id;
        this.path = path;
        this.store = store;
        this.documentRootConfigs = observable.map<string, PageConfig>(
            this.isAutoGenerated ? [] : [[id, { type: 'mdx_comment', position: 0 }]],
            { deep: false }
        );
    }

    @computed
    get isAutoGenerated() {
        return this.id.startsWith(AUTO_GENERATED_PAGE_PREFIX);
    }

    @computed
    get isLandingpage() {
        return this.store.sidebarVersions.some((version) => version.rootPaths.includes(this.path));
    }

    @computed
    get parentPath() {
        const parts = this.path.split('/').slice(0, -2);
        while (parts.length > 1) {
            const parentPath = `${parts.join('/')}/`;
            const parentPage = this.store.pages.find((p) => p.path === parentPath);
            if (parentPage) {
                return parentPage.path;
            }
            if (this.store.sidebarVersions.some((v) => v.versionPath === parentPath)) {
                return parentPath;
            }
            parts.splice(-1, 1);
        }
        return '/';
    }

    @computed
    get subPages() {
        return this.store.pages.filter((page) => page.parentPath === this.path && !page.isLandingpage);
    }

    @action
    setDynamicValue(key: string, value?: string) {
        if (value === undefined) {
            this.dynamicValues.delete(key);
            return;
        }
        this.dynamicValues.set(key, value);
    }

    @action
    assertDocumentRoot(doc: iDocument<any>) {
        if (process.env.NODE_ENV === 'production') {
            return;
        }
        if (!this.documentRootConfigs.has(doc.documentRootId)) {
            this.store.loadPageIndex(true);
        }
    }

    @action
    addDocumentRootConfig(id: string, config: PageConfig) {
        this.documentRootConfigs.set(id, { type: config.type, position: config.position });
    }

    @computed
    get documentRoots() {
        return this.store.root.documentRootStore.documentRoots
            .filter((doc) => this.documentRootConfigs.has(doc.id) && !doc.isDummy)
            .sort((a, b) => {
                const pA = this.documentRootConfigs.get(a.id)!.position;
                const pB = this.documentRootConfigs.get(b.id)!.position;
                return pA - pB;
            });
    }

    @computed
    get documents() {
        return this.documentRoots
            .flatMap((doc) => doc.firstMainDocument)
            .filter((d) => d?.root?.meta.pagePosition)
            .sort((a, b) => a!.root!.meta!.pagePosition - b!.root!.meta.pagePosition);
    }

    @computed
    get studentGroupName() {
        const pathParts = this.path.split('/').filter((p) => p.length > 0);
        const name = pathParts[0];
        if (!name) {
            return;
        }
        if (this.store.sidebarVersionPaths.has(`/${name}/`)) {
            return name;
        }
        return;
    }

    @computed
    get studentGroupScope() {
        const name = this.studentGroupName;
        if (!name) {
            return '/';
        }
        return `/${name}/`;
    }

    @computed
    get primaryViewedStudentGroupName() {
        return this._primaryViewedStudentGroupName ?? this.store.currentStudentGroupName;
    }

    @action
    setPrimaryViewedStudentGroupName(name?: string) {
        this._primaryViewedStudentGroupName = name;
    }

    get hasCustomViewedPrimaryStudentGroup() {
        return !!this._primaryViewedStudentGroupName;
    }

    @computed
    get primaryViewedStudentGroup() {
        return this._primaryViewedStudentGroupName
            ? this.store.root.studentGroupStore.findByName(this._primaryViewedStudentGroupName)
            : this.store.root.studentGroupStore.findByName(this.primaryViewedStudentGroupName);
    }

    @action
    setPrimaryViewedStudentGroup(group?: StudentGroup) {
        const isCurrent = group && this.primaryViewedStudentGroup?.id === group.id;
        const isInFocus = group && this._viewedStudentGroup?.parentIds.includes(group.id);
        if (isCurrent || isInFocus) {
            this.setPrimaryViewedStudentGroupName(undefined);
            this._viewedStudentGroup = undefined;
            return;
        }
        this.setPrimaryViewedStudentGroupName(group?.name);
        if (group) {
            this._viewedStudentGroup = undefined;
        }
    }

    /**
     * loads all linked document roots (added by #addDocumentRoot)
     */
    @action
    loadLinkedDocumentRoots(force = false) {
        if (!force && !this.store.root.userStore.isUserSwitched) {
            return;
        }
        if (!force && this.initialLoadComplete) {
            return;
        }
        this.initialLoadComplete = true;
        return this.store.loadAllDocuments(this);
    }

    get TaskableDocuments() {
        return this.store.root.componentStore.taskableDocuments;
    }

    @computed
    get taskableDocumentRootIds() {
        return [...this.documentRootConfigs.keys()].filter((id) => {
            const config = this.documentRootConfigs.get(id)!;
            return this.TaskableDocuments.has(config.type);
        });
    }

    @computed
    get taskableDocuments(): iTaskableDocument[] {
        const uid = this.store.root.userStore.viewedUserId;
        if (!uid) {
            return [];
        }
        return this.taskableDocumentRootIds.flatMap((rid) => {
            return this.store.root.documentStore
                .findByDocumentRoot(rid)
                .filter(
                    (doc) => doc.authorId === uid && this.TaskableDocuments.has(doc.type)
                ) as iTaskableDocument[];
        });
    }

    @computed
    get stepsOnPage(): number {
        // use the id's, otherwise not yet created documents would not be counted,
        // which leads to wrong progress values until all documents are loaded
        return this.taskableDocumentRootIds.length;
    }

    @computed
    get stepsOnDirectSubPages(): number {
        return this.subPages.reduce((sum, page) => sum + page.stepsOnPage, 0);
    }

    @computed
    get totalSteps(): number {
        return this.stepsOnPage + this.subPages.reduce((sum, page) => sum + page.totalSteps, 0);
    }

    @computed
    get progress(): number {
        return (
            this.taskableDocuments.filter((d) => d.isDone).length +
            this.subPages.reduce((sum, page) => sum + page.progress, 0)
        );
    }

    @computed
    get isDone(): boolean {
        return this.progress > 0 && this.progress >= this.totalSteps;
    }

    @computed
    get editingIconState() {
        if (this.isDone) {
            return { path: mdiCheckCircleOutline, color: IfmColors.green };
        }
        const level = this.progress / this.totalSteps;
        if (this.progress === 0) {
            return { path: mdiSpeedometerSlow, color: IfmColors.gray };
        }
        if (level < 1 / 3) {
            return { path: mdiSpeedometerSlow, color: IfmColors.red };
        }
        if (level < 2 / 3) {
            return { path: mdiSpeedometerMedium, color: IfmColors.orange };
        }
        return { path: mdiSpeedometer, color: IfmColors.lightGreen };
    }

    @computed
    get editingState(): iTaskableDocument[] {
        return this.taskableDocuments;
    }

    @action
    toggleViewedStudentGroup(studentGroup: StudentGroup) {
        if (this._viewedStudentGroup && this._viewedStudentGroup.id === studentGroup.id) {
            this._viewedStudentGroup = undefined;
        } else {
            this._viewedStudentGroup = studentGroup;
        }
    }

    @computed
    get childStudentGroups() {
        if (this.primaryViewedStudentGroup) {
            return this.primaryViewedStudentGroup.children;
        }
        return _.orderBy(
            this.store.root.studentGroupStore.managedStudentGroups.filter((sg) => !!sg.parentId),
            ['name'],
            ['asc']
        );
    }

    @computed
    get viewedStudentGroup() {
        return this._viewedStudentGroup || this.primaryViewedStudentGroup;
    }

    @computed
    get editingStateByUsers() {
        return _.groupBy(
            this.taskableDocumentRootIds
                .flatMap((rid) => {
                    return this.store.root.documentStore
                        .findByDocumentRoot(rid)
                        .filter((doc) => this.TaskableDocuments.has(doc.type)) as iTaskableDocument[];
                })
                .filter((doc) =>
                    this.viewedStudentGroup ? this.viewedStudentGroup.userIds.has(doc.authorId) : true
                ),
            (doc) => doc.authorId
        );
    }

    @computed
    get userIdsWithoutEditingState(): string[] {
        const editingStates = this.editingStateByUsers;
        const userIds = new Set<string>(
            this.viewedStudentGroup?.userIds ||
                this.store.root.studentGroupStore.managedStudentGroups.flatMap((g) => [...g.userIds])
        );
        return [...userIds].filter((userId) => !editingStates[userId]);
    }
}
